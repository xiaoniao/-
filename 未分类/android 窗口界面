窗口就是由一系列的视图按照一定的布局组织起来的。
实际上，每一个视图都是一个控件，这些控制可以将自己的UI绘制在窗口的绘图表面上，同时还可以与用户进行交互，即获得用户的键盘或者触摸屏输入


第一个材料是画布，第二个材料是用户输入。有画布才能绘制UI，而有用户输入才能与用户进行交互。

应用程序窗口，即Activity窗口，是由一个PhoneWindow对象，一个DecorView对象，以及一个ViewRoot对象来描述的。
其中，PhoneWindow对象用来描述窗口对象，DecorView对象用来描述窗口的顶层视图，ViewRoot对象除了用来与WindowManagerService服务通信之外，还用来接收用户输入。
窗口控件本身也是一个视图，即一个View对象，它们是以树形结构组织在一起形成整个窗口的UI的。


PhoneWindow 描述窗口对象
    DecorView 描述窗口的顶层视图
        ViewRoot 用来与WindowManagerService服务通信之外，还用来接收用户输入

测量（Measure）
布局（Layout）
绘制（Draw）

这三个按顺序执行


Java层的Canvas实际上是封装了C++层的SkCanvas。(skia)
C++层的SkCanvas内部有一块图形缓冲区，这块图形缓冲区就是窗口的绘图表面（Surface）里面的那块图形缓冲区。
窗口的绘图表面里面的那块图形缓冲区实际上是一块匿名共享内存，它是SurfaceFlinger服务负责创建的。

SurfaceFlinger服务创建完成这块匿名共享内存之后，就会将其返回给窗口所运行在的进程。(疑问？一个程序创建几次，还是一个窗口创建一次)
窗口所运行在的进程获得了这块匿名共享内存之后，就会映射到自己的进程空间来，因此，窗口的控件就可以在本进程内访问这块匿名共享内存了，实际上就是往这块匿名共享内存填入UI数据。
注意，这个过程执行完成之后，控件的UI还没有反映到屏幕上来，因为这时候将控件的UI数据填入到图形缓冲区而已。(疑问？什么是 UI 数据)

窗口的UI的显示是WindowManagerService服务来控制的。
因此，当窗口的所有控件都绘制完成自己的UI之后，窗口就会向WindowManagerService服务发送一个Binder进程间程通信请求。
WindowManagerService服务接收到这个Binder进程间程通信请求之后，就会请求SurfaceFlinger服务刷新相应的窗口的UI。


控件的UI虽然是在一块简单的画布进行绘制，但是其中蕴含了丰富的知识点，并且需要[应用程序进程]、[WindowManagerService服务]和[SurfaceFlinger服务]三方紧密而有序的配合。

(1). 一个窗口的所有控件的UI都是绘制在窗口的绘图表面上的，也就是说，一个窗口的所有控件的UI数据都是填写在同一块图形缓冲区中；
(2). 一个窗口的所有控件的UI的绘制操作是在主线程中执行的，事实上，所有与UI相关的操作都是必须是要在主线程中执行，否则的话，就会抛出一个类型为CalledFromWrongThreadException的异常来。


那么，有没有办法让某一个控件的UI享有独立的图形缓冲区呢？
也就是这个控件不将自己的UI数据填入到它的宿主窗口的绘图表面的图形缓冲区里面去。这样做的好处是显而易见——可以在这个独立的线程执行相对比较耗时的UI绘制操作而不会导致主线程无法及时响应用户输入。——SurfaceView。


在Android系统中，其它的Android控件与TextView控件的实现框架都是类似的，区别就在于实现细节和所表现的UI不一样，而且它们一般都有一个共同的特点，那就是都在宿主窗口的绘图表面上进行UI绘制。
在接下来的一篇文章中，我们就分析另外一个种以SurfaceView为代表的特殊控件，它们的UI是绘制在一个专用的绘图表面上面的，即它们不与宿主窗口共享同一个绘图表面。敬请关注！


(1).窗口共享内存区域
(2).单独一个内存区域 SurfaceView










.
